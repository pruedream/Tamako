(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{339:function(a,t,r){"use strict";r.r(t);var e=r(4),s=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),t("h2",{attrs:{id:"结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[a._v("#")]),a._v(" 结构")]),a._v(" "),t("h2",{attrs:{id:"java字节码文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java字节码文件"}},[a._v("#")]),a._v(" Java字节码文件")]),a._v(" "),t("h3",{attrs:{id:"组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组成"}},[a._v("#")]),a._v(" 组成")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130184238573.png",alt:"image-20231130184238573"}})]),a._v(" "),t("br"),a._v(" "),t("p",[t("strong",[a._v("基本信息：")]),a._v(" 主要是两个，一个是魔数，一个是版本号。魔数用来校验文件的类型（是否是class文件），因为不能做到凭借文件扩展名就能判断文件类型，软件版本号用来标识编译该字节码文件的jdk的版本号，当前字节码版本号需要小于实际运行时jdk的的版本号才能运行。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130192201790.png",alt:"image-20231130192201790"}})]),a._v(" "),t("br"),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130192357925.png",alt:"image-20231130192357925"}})]),a._v(" "),t("br"),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130192421422.png",alt:"image-20231130192421422"}})]),a._v(" "),t("h3",{attrs:{id:"重点介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重点介绍"}},[a._v("#")]),a._v(" 重点介绍")]),a._v(" "),t("br"),a._v(" "),t("h4",{attrs:{id:"常量池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常量池"}},[a._v("#")]),a._v(" 常量池")]),a._v(" "),t("p",[a._v("常量池存放一些字符串常量，会在方法里的字节码指令中被引用。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130185033894.png",alt:"image-20231130185033894"}})]),a._v(" "),t("br"),a._v(" "),t("h4",{attrs:{id:"方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130191624595.png",alt:"image-20231130191624595"}})]),a._v(" "),t("h5",{attrs:{id:"简单字节码指令的阅读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单字节码指令的阅读"}},[a._v("#")]),a._v(" 简单字节码指令的阅读")]),a._v(" "),t("p",[a._v("局部变量表，，方法栈")]),a._v(" "),t("h2",{attrs:{id:"类的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的生命周期"}},[a._v("#")]),a._v(" 类的生命周期")]),a._v(" "),t("p",[a._v("最重要的是初始化阶段，因为这个阶段可以进行人为的干涉")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130194107705.png",alt:"image-20231130194107705"}})]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"加载阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加载阶段"}},[a._v("#")]),a._v(" 加载阶段")]),a._v(" "),t("p",[a._v("两个对象")]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"连接阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接阶段"}},[a._v("#")]),a._v(" 连接阶段")]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"初始化阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化阶段"}},[a._v("#")]),a._v(" 初始化阶段")]),a._v(" "),t("br"),a._v(" "),t("h2",{attrs:{id:"类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),t("br"),a._v(" "),t("h2",{attrs:{id:"运行时数据区-jvm管理的内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区-jvm管理的内存"}},[a._v("#")]),a._v(" 运行时数据区（JVM管理的内存）")]),a._v(" "),t("p",[a._v("线程共享的是每个线程都可以访问，线程不共享的是每个线程都有自己的一份")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130195007649.png",alt:"image-20231130195007649"}})]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"程序计数器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),t("p",[a._v("字节码文件加载到内存后，每一条字节码指令都会有自己的内存地址，")]),a._v(" "),t("p",[a._v("程序计数器的作用就是保存下一条将要执行的字节码指令的地址，方便解释器获取到转化成机器指令运行，在此基础上产生两个特别重要的作用")]),a._v(" "),t("p",[t("strong",[a._v("控制程序的执行，实现分支，跳转，异常等逻辑。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130200212758.png",alt:"image-20231130200212758"}})]),a._v(" "),t("br"),a._v(" "),t("p",[a._v("多线程环境下，能够保存线程将执行的下一条指令地址，在得到cpu的执行权时继续运行程序。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130200244485.png",alt:"image-20231130200244485"}})]),a._v(" "),t("p",[a._v("该区域不会出现内存溢出，因为程序计数器中只会保存一个固定长度的内存地址，（用来存放字节码指令的地址）而内存地址的长度是不会发生改变的，具体的长度要看具体的硬件配置。")]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"java虚拟机栈和本地方法栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈和本地方法栈"}},[a._v("#")]),a._v(" Java虚拟机栈和本地方法栈")]),a._v(" "),t("p",[a._v("Java虚拟机栈存放的是java语言编写的方法的栈帧，本地方法栈存放的是C++编写的方法的栈帧，"),t("strong",[a._v("栈帧就是存放该方法的状态和变量的栈空间。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130205205490.png",alt:"image-20231130205205490"}})]),a._v(" "),t("p",[t("strong",[a._v("Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。")])]),a._v(" "),t("h4",{attrs:{id:"栈帧的组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈帧的组成"}},[a._v("#")]),a._v(" 栈帧的组成")]),a._v(" "),t("p",[t("strong",[a._v("栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130204700028.png",alt:"image-20231130204700028"}})]),a._v(" "),t("br"),a._v(" "),t("h5",{attrs:{id:"局部变量表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#局部变量表"}},[a._v("#")]),a._v(" 局部变量表")]),a._v(" "),t("p",[a._v("用于存放方法执行过程中的所有局部变量。")]),a._v(" "),t("p",[t("strong",[a._v("局部变量表的结构")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130205520162.png",alt:"image-20231130205520162"}})]),a._v(" "),t("p",[a._v("槽主要保存一下几种数据：")]),a._v(" "),t("ul",[t("li",[a._v("方法参数 。其顺序与方法中参数定义的顺序一致。")]),a._v(" "),t("li",[a._v("实例方法的this对象（第一个槽）")]),a._v(" "),t("li",[a._v("方法内申明的局部变量")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130205813329.png",alt:"image-20231130205813329"}})]),a._v(" "),t("br"),a._v(" "),t("h5",{attrs:{id:"操作数栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作数栈"}},[a._v("#")]),a._v(" 操作数栈")]),a._v(" "),t("p",[a._v("操作数栈用于存放方法执行过程中的中间数据。在对局部变量进行操作的时候是需要将其从局部变量表中copy到操作数栈中的。")]),a._v(" "),t("p",[a._v("在编译期就可以确定操作数栈的最大深度,从而在执行时正确的分配内存大小。")]),a._v(" "),t("br"),a._v(" "),t("h5",{attrs:{id:"帧数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#帧数据"}},[a._v("#")]),a._v(" 帧数据")]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),t("br"),a._v(" "),t("h2",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),t("br"),a._v(" "),t("h2",{attrs:{id:"jvm调优"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优"}},[a._v("#")]),a._v(" JVM调优")])])}),[],!1,null,null,null);t.default=s.exports}}]);