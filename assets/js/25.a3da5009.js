(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{388:function(a,t,e){"use strict";e.r(t);var r=e(4),s=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240118140216097.png",alt:"image-20240118140216097"}})]),a._v(" "),t("p",[t("strong",[a._v("个人理解，JVM内存空间，也就是JVM管理的内存，相当于就是存放数据的地方，由执行引擎来从中获取数据进行相关操作。")])]),a._v(" "),t("h2",{attrs:{id:"jdk、jre、jvm区别与联系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk、jre、jvm区别与联系"}},[a._v("#")]),a._v(" JDK、JRE、JVM区别与联系")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240105222954518.png",alt:"image-20240105222954518"}})]),a._v(" "),t("h3",{attrs:{id:"jdk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk"}},[a._v("#")]),a._v(" JDK")]),a._v(" "),t("p",[a._v("JDK(Java SE Development Kit)，Java标准开发包，它"),t("strong",[a._v("提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库（就是String、集合之类的）等")]),a._v("。")]),a._v(" "),t("p",[a._v("下图是JDK的安装目录：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/1362965-20190114160755933-897193066.png",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"jre"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jre"}},[a._v("#")]),a._v(" JRE")]),a._v(" "),t("p",[a._v("**JRE( Java Runtime Environment) 、Java运行环境，主要提供java程序的运行环境，**用于解释执行Java的字节码文件。普通用户而只需要安装JRE（Java Runtime Environment）来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。")]),a._v(" "),t("p",[a._v("下图是JRE的安装目录：里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/1362965-20190114161959489-1682755970.png",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"jvm-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-2"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),t("p",[a._v("**JVM(Java Virtual Mechinal)，Java虚拟机，负责解释执行字节码文件为计算机可以识别运行的机器码指令，**是JRE的一部分。它是整个java实现跨平台的最核心的部分，是可运行java字节码文件的虚拟计算机。")]),a._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("p",[a._v("开发人员需要JDK，因为需要用来开发java程序以及编译java文件，")]),a._v(" "),t("p",[a._v("有了项目的字节码文件后运行，需要JRE，因为要提供java程序的运行环境，")]),a._v(" "),t("p",[a._v("字节码文件会被加载到JVM中，由JVM解释字节码指令转化为计算机可以识别运行的机器码指令。")]),a._v(" "),t("h2",{attrs:{id:"java字节码文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java字节码文件"}},[a._v("#")]),a._v(" Java字节码文件")]),a._v(" "),t("h3",{attrs:{id:"组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组成"}},[a._v("#")]),a._v(" 组成")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130184238573.png",alt:"image-20231130184238573"}})]),a._v(" "),t("br"),a._v(" "),t("p",[t("strong",[a._v("基本信息：")]),a._v(" 主要是两个，一个是魔数，一个是版本号。魔数用来校验文件的类型（是否是class文件），因为不能做到凭借文件扩展名就能判断文件类型，软件版本号用来标识编译该字节码文件的jdk的版本号，当前字节码版本号需要小于实际运行时jdk的的版本号才能运行。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130192201790.png",alt:"image-20231130192201790"}})]),a._v(" "),t("br"),a._v(" "),t("p",[a._v("魔数就是Java字节码文件的文件头，软件不是通过文件扩展去判断文件类型的，而是通过文件开头的几个字节，也就是文件头去判断文件类型，魔数的作用就是用于在JVM加载的时候判断是不是字节码文件，不是的话软件会报错。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130192357925.png",alt:"image-20231130192357925"}})]),a._v(" "),t("br"),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130192421422.png",alt:"image-20231130192421422"}})]),a._v(" "),t("p",[a._v("一般来说，JDK的版本号就是 主版本号-44 ，如52就是JDK8。至于副版本号一般不太关心。可以理解为用于细分主版本号。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240105223025416.png",alt:"image-20240105223025416"}})]),a._v(" "),t("h3",{attrs:{id:"重点介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重点介绍"}},[a._v("#")]),a._v(" 重点介绍")]),a._v(" "),t("br"),a._v(" "),t("h4",{attrs:{id:"常量池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常量池"}},[a._v("#")]),a._v(" 常量池")]),a._v(" "),t("p",[a._v("常量池存放一些字符串常量，会在方法里的字节码指令中被引用。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130185033894.png",alt:"image-20231130185033894"}})]),a._v(" "),t("br"),a._v(" "),t("h4",{attrs:{id:"方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130191624595.png",alt:"image-20231130191624595"}})]),a._v(" "),t("h5",{attrs:{id:"简单字节码指令的阅读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单字节码指令的阅读"}},[a._v("#")]),a._v(" 简单字节码指令的阅读")]),a._v(" "),t("p",[a._v("阅读字节码指令，解释下图问题。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240118122612950.png",alt:"image-20240118122612950"}})]),a._v(" "),t("h2",{attrs:{id:"类的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的生命周期"}},[a._v("#")]),a._v(" 类的生命周期")]),a._v(" "),t("p",[a._v("最重要的是初始化阶段，因为这个阶段可以进行人为的干涉")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130194107705.png",alt:"image-20231130194107705"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214125126251.png",alt:"image-20240214125126251"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214125207011.png",alt:"image-20240214125207011"}})]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"加载阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加载阶段"}},[a._v("#")]),a._v(" 加载阶段")]),a._v(" "),t("p",[a._v("通过类加载器将不同渠道的字节码文件加载到内存当中，在方法区上生成一个对应的InstanceKlass对象来保存类的相关信息（也就是字节码文件的相关信息），然后在堆区生成对应的Class对象（就是反射时常用的）该对象同样保存类的相关信息，如字段，方法等，但要少于InstanceKlass对象，原因在于开发者实际上不需要访问方法区里的所有信息，为了控制开发者访问数据的范围，和数据的安全性，开发者通过访问Class对象来获取类的相关信息。两个对象之间彼此有引用相互关联。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214102935062.png",alt:"image-20240214102935062"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214103638186.png",alt:"image-20240214103638186"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214103142550.png",alt:"image-20240214103142550"}})]),a._v(" "),t("p",[a._v("​      "),t("strong",[a._v("注意：此时静态变量并未处理，此处知识说明静态变量会存储在该地方。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214103210048.png",alt:"image-20240214103210048"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214105708440.png",alt:"image-20240214105708440"}})]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"连接阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接阶段"}},[a._v("#")]),a._v(" 连接阶段")]),a._v(" "),t("p",[a._v("链接阶段可细分为三个阶段")]),a._v(" "),t("ul",[t("li",[a._v("验证：校验字节码文件是否符合JVM虚拟机规范")]),a._v(" "),t("li",[a._v("准备：在堆上的Class对象中为静态变量分配内存并初始化（初始化的原因是防止旧的内存地址上有数据残留）。如果有值不会赋值，但是如果是final就会在该阶段直接赋值")]),a._v(" "),t("li",[a._v("解析：在字节码文件当中使用常量池的数据是通过"),t("strong",[a._v("符号引用")]),a._v("。具体表现为常量池里的常量是有编号的，在他处使用就是通过编号访问，"),t("strong",[a._v("解析阶段会将符号引用转化为内存地址的直接引用")]),a._v("。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214110521252.png",alt:"image-20240214110521252"}})]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"初始化阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化阶段"}},[a._v("#")]),a._v(" 初始化阶段")]),a._v(" "),t("p",[a._v("初始化阶段：从"),t("strong",[a._v("代码层面")]),a._v("上来说会执行类的静态代码块的代码，并且为静态变量赋值。从"),t("strong",[a._v("字节码层面")]),a._v("来讲是会执行"),t("strong",[a._v("字节码文件中的clinit方法")]),a._v("里的字节码指令。")]),a._v(" "),t("p",[t("strong",[a._v("存在没有初始化过程的情况")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214130733460.png",alt:"image-20240214130733460"}})]),a._v(" "),t("p",[t("strong",[a._v("一般会在以下情况触发初始化")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214130414065.png",alt:"image-20240214130414065"}})]),a._v(" "),t("p",[t("strong",[a._v("继承情况下的初始化")]),a._v(" ：父类初始化不会影响父类，子类初始化会先初始化父类。"),t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240214130842575.png",alt:"image-20240214130842575"}})]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"使用阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用阶段"}},[a._v("#")]),a._v(" 使用阶段")]),a._v(" "),t("p",[a._v("就正常使用，没啥特别。")]),a._v(" "),t("h3",{attrs:{id:"卸载阶段-未完成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#卸载阶段-未完成"}},[a._v("#")]),a._v(" 卸载阶段---未完成")]),a._v(" "),t("p",[a._v("与累计回收有关，待续")]),a._v(" "),t("h2",{attrs:{id:"类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),t("p",[a._v("类加载器：类加载器是一种将字节码文件加载到内存上的技术，但是也仅仅就是加载到内存上，会调用本地接口的方法去在方法区与堆去上分别创建类的InstanceKlass对象和Class对象。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215130258268.png",alt:"image-20240215130258268"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215130430790.png",alt:"image-20240215130430790"}})]),a._v(" "),t("h3",{attrs:{id:"类加载器的分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器的分类"}},[a._v("#")]),a._v(" 类加载器的分类")]),a._v(" "),t("p",[a._v("大体分为两类")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("有JVM源码提供的，一般使用C++、C 语言编写，如HotSpot就是用C++写的。")])]),a._v(" "),t("li",[t("p",[a._v("JDK提供的、使用Java语言编写的。")])])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215130757517.png",alt:"image-20240215130757517"}})]),a._v(" "),t("h4",{attrs:{id:"jdk8版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk8版本"}},[a._v("#")]),a._v(" JDK8版本")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215131145961.png",alt:"image-20240215131145961"}})]),a._v(" "),t("p",[t("strong",[a._v("启动器加载器：负责加载Java中的核心类库，比如说我们常用的String，List。实际上你同样也可使用该加载器帮你加载指令的Jar包，但是不规范")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215132903373.png",alt:"image-20240215132903373"}})]),a._v(" "),t("p",[t("strong",[a._v("扩展类加载器：负责加载一些通用的且不核心的类，实际上你同样也可使用该加载器帮你加载指令的Jar包，但是不规范")]),a._v("。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215154943222.png",alt:"image-20240215154943222"}})]),a._v(" "),t("p",[t("strong",[a._v("应用程序加载器：主要负责加载classpath下的类文件。也就是我们编写的应用的类的字节码文件，以及应用所依赖的第三方jar包文件。")])]),a._v(" "),t("p",[t("strong",[a._v("每个类加载器都有自己要加载的目录，会从该目录中加载字节码文件，我们也可以指定去加载额外的目录，当目录在多个类加载器所要加载的目录中存在时，就需要双亲委派机制来决定具体由哪个类加载器加载")])]),a._v(" "),t("h4",{attrs:{id:"jdk8以后的版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk8以后的版本"}},[a._v("#")]),a._v(" JDK8以后的版本")]),a._v(" "),t("h3",{attrs:{id:"双亲委派机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[a._v("#")]),a._v(" 双亲委派机制")]),a._v(" "),t("p",[a._v("所谓双亲委派机制是一种解决在程序运行中，一个类到底是由哪个类加载器来加载的机制。")]),a._v(" "),t("p",[a._v("类被加载进内存有两点最基本的要求：")]),a._v(" "),t("ul",[t("li",[a._v("要避免重复的加载")]),a._v(" "),t("li",[a._v("要保证类加载的安全性，")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215161412885.png",alt:"image-20240215161412885"}})]),a._v(" "),t("p",[a._v("是什么，用于解决什么问题，详细介绍")]),a._v(" "),t("p",[t("strong",[a._v("具体流程")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215162016906.png",alt:"image-20240215162016906"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215162328356.png",alt:"image-20240215162328356"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215162433405.png",alt:"image-20240215162433405"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240215161755104.png",alt:"image-20240215161755104"}})]),a._v(" "),t("h3",{attrs:{id:"如何打破双亲委派机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何打破双亲委派机制"}},[a._v("#")]),a._v(" 如何打破双亲委派机制")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240216144238317.png",alt:"image-20240216144238317"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240216144343297.png",alt:"image-20240216144343297"}})]),a._v(" "),t("p",[a._v("findClass是实现从什么地方获取字节码文件，封装成字节数组，然后调用defineClass，该方法就是本地接口（final修饰）了，负责将字节码文件加载进内存，做的事情就是类的加载阶段做的事情")]),a._v(" "),t("p",[a._v("为什么，怎么打破")]),a._v(" "),t("h4",{attrs:{id:"打破的几种方式-未完成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打破的几种方式-未完成"}},[a._v("#")]),a._v(" 打破的几种方式---未完成")]),a._v(" "),t("br"),a._v(" "),t("h2",{attrs:{id:"运行时数据区-jvm管理的内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区-jvm管理的内存"}},[a._v("#")]),a._v(" 运行时数据区（JVM管理的内存）")]),a._v(" "),t("p",[a._v("线程共享的是每个线程都可以访问，线程不共享的是每个线程都有自己的一份（无线程安全问题，线程结束就会释放）")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130195007649.png",alt:"image-20231130195007649"}})]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"程序计数器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),t("p",[a._v("字节码文件加载到内存后，每一条字节码指令都会有自己的内存地址，")]),a._v(" "),t("p",[a._v("程序计数器的作用就是保存下一条将要执行的字节码指令的地址，方便解释器获取到转化成机器指令运行，在此基础上产生两个特别重要的作用")]),a._v(" "),t("p",[t("strong",[a._v("控制程序的执行，实现分支，跳转，异常等逻辑。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130200212758.png",alt:"image-20231130200212758"}})]),a._v(" "),t("br"),a._v(" "),t("p",[t("strong",[a._v("多线程环境下，能够保存线程将执行的下一条指令地址，在得到cpu的执行权时继续运行程序。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130200244485.png",alt:"image-20231130200244485"}})]),a._v(" "),t("p",[a._v("该区域不会出现内存溢出，因为程序计数器中只会保存一个固定长度的内存地址，（用来存放字节码指令的地址）而内存地址的长度是不会发生改变的，具体的长度要看具体的硬件配置。")]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"java虚拟机栈和本地方法栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈和本地方法栈"}},[a._v("#")]),a._v(" Java虚拟机栈和本地方法栈")]),a._v(" "),t("p",[a._v("Java虚拟机栈存放的是java语言编写的方法的栈帧，本地方法栈存放的是C++编写的方法的栈帧，**栈帧就是存放该方法的状态和变量的栈空间。**HotSpot虚拟机则是没这个区分，都用一个Java虚拟机栈存放栈帧。")]),a._v(" "),t("p",[a._v("已经执行完的方法的栈帧会从栈中弹出，栈中的方法遵循先进后出的规则执行。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130205205490.png",alt:"image-20231130205205490"}})]),a._v(" "),t("p",[t("strong",[a._v("Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。")])]),a._v(" "),t("h4",{attrs:{id:"栈帧的组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈帧的组成"}},[a._v("#")]),a._v(" 栈帧的组成")]),a._v(" "),t("p",[a._v("栈帧本质就是存放着方法的变量和相关状态数据，主要提供数据，具体对数据的操作来自于程序计数器里的字节码指令")]),a._v(" "),t("p",[t("strong",[a._v("栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130204700028.png",alt:"image-20231130204700028"}})]),a._v(" "),t("br"),a._v(" "),t("h5",{attrs:{id:"局部变量表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#局部变量表"}},[a._v("#")]),a._v(" 局部变量表")]),a._v(" "),t("p",[a._v("用于存放方法执行过程中的所有局部变量。")]),a._v(" "),t("p",[t("strong",[a._v("局部变量表的结构")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130205520162.png",alt:"image-20231130205520162"}})]),a._v(" "),t("p",[a._v("槽主要保存一下几种数据：")]),a._v(" "),t("ul",[t("li",[a._v("方法参数 。其顺序与方法中参数定义的顺序一致。")]),a._v(" "),t("li",[a._v("实例方法的this对象（第一个槽）")]),a._v(" "),t("li",[a._v("方法内申明的局部变量")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/pruedream/PictureBed@main/image/image-20231130205813329.png",alt:"image-20231130205813329"}})]),a._v(" "),t("br"),a._v(" "),t("h5",{attrs:{id:"操作数栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作数栈"}},[a._v("#")]),a._v(" 操作数栈")]),a._v(" "),t("p",[a._v("操作数栈用于存放方法执行过程中的中间数据。在对局部变量进行操作的时候是需要将其从局部变量表中copy到操作数栈中的。")]),a._v(" "),t("p",[a._v("在编译期就可以确定操作数栈的最大深度,从而在执行时正确的分配内存大小。")]),a._v(" "),t("br"),a._v(" "),t("h5",{attrs:{id:"帧数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#帧数据"}},[a._v("#")]),a._v(" 帧数据")]),a._v(" "),t("p",[a._v("主要包括：")]),a._v(" "),t("p",[t("strong",[a._v("动态链接")])]),a._v(" "),t("p",[a._v("引用别的类的属性或方法在类加载阶段不会将符号引用变成内存地址的直接引用。")]),a._v(" "),t("p",[a._v("运行时常量池？？？")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240118185504141.png",alt:"image-20240118185504141"}})]),a._v(" "),t("p",[t("strong",[a._v("方法出口")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240118183852452.png",alt:"image-20240118183852452"}})]),a._v(" "),t("p",[t("strong",[a._v("异常表")])]),a._v(" "),t("p",[t("strong",[a._v("异常表里面存放着该方法的异常处理逻辑中，对应的异常情况应该跳转的字节码指令位置，控制了方法中存在异常处理时的代码跳转逻辑。实际上就是实现了异常的处理。在编译的时候就已经生成。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240118173449602.png",alt:"image-20240118173449602"}})]),a._v(" "),t("p",[a._v("在编译的时候就已经生成")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240118173702924.png",alt:"image-20240118173702924"}})]),a._v(" "),t("h4",{attrs:{id:"栈内存溢出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈内存溢出"}},[a._v("#")]),a._v(" 栈内存溢出")]),a._v(" "),t("p",[t("strong",[a._v("会出现内存溢出")])]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),t("p",[a._v("创建出来的对象基本都存在堆上，静态变量也存在于堆上。")]),a._v(" "),t("p",[t("strong",[a._v("该内存区域存在内存溢出")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240218120532686.png",alt:"image-20240218120532686"}})]),a._v(" "),t("h4",{attrs:{id:"堆内存的划分-未完成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆内存的划分-未完成"}},[a._v("#")]),a._v(" 堆内存的划分---未完成")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240218122055150.png",alt:"image-20240218122055150"}})]),a._v(" "),t("p",[a._v("随着程序使用过程中Used的空间越来越大，total开始变得不够，此时会向JVM申请扩大total(可用堆内存) 但是不是超过Max(最大堆内存)")]),a._v(" "),t("p",[a._v("并不是used=total=max就发生堆内存溢出，判断情况比较复杂，这与垃圾回收有关")]),a._v(" "),t("h4",{attrs:{id:"如何设置可用堆内存与最大堆内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何设置可用堆内存与最大堆内存"}},[a._v("#")]),a._v(" 如何设置可用堆内存与最大堆内存")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240218122518260.png",alt:"image-20240218122518260"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240218122010586.png",alt:"image-20240218122010586"}})]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),t("p",[a._v("方法区是存在溢出的")]),a._v(" "),t("h4",{attrs:{id:"组成-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组成-2"}},[a._v("#")]),a._v(" 组成")]),a._v(" "),t("p",[t("strong",[a._v("字符串常量池只存放字符串常量，但运行时常量池不是，他还存放字段名，类名，等常量")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240218154643127.png",alt:"image-20240218154643127"}})]),a._v(" "),t("p",[t("strong",[a._v("存放类的元信息")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240218154752700.png",alt:"image-20240218154752700"}})]),a._v(" "),t("p",[t("strong",[a._v("运行时常量池")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240218154909821.png",alt:"image-20240218154909821"}})]),a._v(" "),t("p",[t("strong",[a._v("字符串常量池")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219141711246.png",alt:"image-20240219141711246"}})]),a._v(" "),t("h4",{attrs:{id:"实现方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[a._v("#")]),a._v(" 实现方式")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240218155031523.png",alt:"image-20240218155031523"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240218155200433.png",alt:"image-20240218155200433"}})]),a._v(" "),t("h4",{attrs:{id:"总结-不同版本之间运行时数据区的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结-不同版本之间运行时数据区的区别"}},[a._v("#")]),a._v(" 总结---不同版本之间运行时数据区的区别")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219145558495.png",alt:"image-20240219145558495"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219145613364.png",alt:"image-20240219145613364"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219145629017.png",alt:"image-20240219145629017"}})]),a._v(" "),t("h2",{attrs:{id:"直接内存-未完成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接内存-未完成"}},[a._v("#")]),a._v(" 直接内存---未完成")]),a._v(" "),t("p",[a._v("与元空间的关系？？？")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219145832185.png",alt:"image-20240219145832185"}})]),a._v(" "),t("br"),a._v(" "),t("h2",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),t("h3",{attrs:{id:"线程不共享部分不参与垃圾回收的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程不共享部分不参与垃圾回收的原因"}},[a._v("#")]),a._v(" 线程不共享部分不参与垃圾回收的原因")]),a._v(" "),t("p",[t("strong",[a._v("该部分的内存空间是线程独有的，随着线程的创建而创建，销毁而销毁。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219151210518.png",alt:"image-20240219151210518"}})]),a._v(" "),t("p",[t("strong",[a._v("内存泄漏")]),a._v("： "),t("strong",[a._v("一个对象如果不再使用，但是没有释放其所占内存，就会发生内存泄漏。")])]),a._v(" "),t("h3",{attrs:{id:"手动与自动的内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#手动与自动的内存管理"}},[a._v("#")]),a._v(" 手动与自动的内存管理")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219150114178.png",alt:"image-20240219150114178"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219150223615.png",alt:"image-20240219150223615"}})]),a._v(" "),t("h3",{attrs:{id:"自动垃圾回收的应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动垃圾回收的应用场景"}},[a._v("#")]),a._v(" 自动垃圾回收的应用场景")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219150518492.png",alt:"image-20240219150518492"}})]),a._v(" "),t("h3",{attrs:{id:"方法区的回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区的回收"}},[a._v("#")]),a._v(" 方法区的回收")]),a._v(" "),t("p",[t("strong",[a._v("方法区的回收主要就是回收不再使用的类。")])]),a._v(" "),t("h4",{attrs:{id:"回收的条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回收的条件"}},[a._v("#")]),a._v(" 回收的条件")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219151517244.png",alt:"image-20240219151517244"}})]),a._v(" "),t("p",[t("strong",[a._v("条件2")]),t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219151535262.png",alt:"image-20240219151535262"}})]),a._v(" "),t("p",[t("strong",[a._v("条件3")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240219151544953.png",alt:"image-20240219151544953"}})]),a._v(" "),t("h3",{attrs:{id:"堆回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆回收"}},[a._v("#")]),a._v(" 堆回收")]),a._v(" "),t("h4",{attrs:{id:"回收的条件与判定对象是否存在引用的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回收的条件与判定对象是否存在引用的方法"}},[a._v("#")]),a._v(" 回收的条件与判定对象是否存在引用的方法")]),a._v(" "),t("p",[a._v("回收的条件的基本思想：")]),a._v(" "),t("p",[t("strong",[a._v("对于强引用来说，只要对象没有强引用引用到该对象，那么就会被回收，否则不会回收")])]),a._v(" "),t("p",[t("strong",[a._v("对于软引用：当内存不足的时候，会回收只被软引用引用的对象。")])]),a._v(" "),t("p",[t("strong",[a._v("弱引用和虚引用：都是不管内存是否不足都会被回收只被弱引用和虚引用引用的对象")])]),a._v(" "),t("h5",{attrs:{id:"引用计数法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数法"}},[a._v("#")]),a._v(" 引用计数法")]),a._v(" "),t("p",[t("strong",[a._v("引用计数法会为每个对象维护一个计数器，对象每被引用一个就加一，如果为0就代表可回收。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312180420610.png",alt:"image-20240312180420610"}})]),a._v(" "),t("h5",{attrs:{id:"可达性分析算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法"}},[a._v("#")]),a._v(" 可达性分析算法")]),a._v(" "),t("p",[a._v("JVM虚拟机采用的就是可达性分析算法来分析对象是否可以被回收")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312181045453.png",alt:"image-20240312181045453"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312181107951.png",alt:"image-20240312181107951"}})]),a._v(" "),t("p",[a._v("**注意：以上两种方法都是用于判定强引用的。**指的引用是强引用。")]),a._v(" "),t("h4",{attrs:{id:"对象的几种引用类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的几种引用类型"}},[a._v("#")]),a._v(" 对象的几种引用类型")]),a._v(" "),t("p",[t("strong",[a._v("注意：引用的概念：引用不是对象，只要你在方法中，代码中用到了其他类，你就是强引用了该类的对象，要不引用就让其为null")])]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("B")]),a._v(" sd "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("B")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  sd是指向"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("B")]),a._v("类的一个对象的引用， sd "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),a._v("这个操作不会对内存上的对象有任何影响，只是减少了引用该对象的一个强引用\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("hr"),a._v(" "),t("p",[a._v("Java 中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。")]),a._v(" "),t("p",[t("strong",[a._v("强引用：无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。")])]),a._v(" "),t("p",[a._v("强引用就是我们平时写代码的引用")]),a._v(" "),t("p",[t("strong",[a._v("软引用：当内存不足的时候，会回收只被软引用引用的对象。")])]),a._v(" "),t("p",[a._v("使用SoftReference来包装普通对象，则该普通对像就有了一个软引用引用他，但SoftReference本身是强引用。")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ReferenceQueue")]),a._v(" queue "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ReferenceQueue")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SoftReference")]),a._v(" reference "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SoftReference")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" queue"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//强引用对象滞空，保留软引用")]),a._v("\nobj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312171556840.png",alt:"image-20240312171556840"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312171219448.png",alt:"image-20240312171219448"}})]),a._v(" "),t("p",[t("strong",[a._v("弱引用和虚引用：都是不管内存是否不足都会被回收只被弱引用和虚引用引用的对象")])]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ReferenceQueue")]),a._v(" queue "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ReferenceQueue")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakReference")]),a._v(" reference "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakReference")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" queue"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//强引用对象滞空，保留弱引用")]),a._v("\nobj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ReferenceQueue")]),a._v(" queue "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ReferenceQueue")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PhantomReference")]),a._v(" reference "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PhantomReference")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" queue"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//强引用对象滞空，保留虚引用")]),a._v("\nobj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("h4",{attrs:{id:"垃圾回收的指导思想-垃圾回收算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收的指导思想-垃圾回收算法"}},[a._v("#")]),a._v(" 垃圾回收的指导思想-垃圾回收算法")]),a._v(" "),t("p",[t("strong",[a._v("垃圾回收算法")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312153555533.png",alt:"image-20240312153555533"}})]),a._v(" "),t("p",[t("strong",[a._v("垃圾回收算法的评判标准")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312153618937.png",alt:"image-20240312153618937"}})]),a._v(" "),t("p",[a._v("可以从以下三个方面来评价：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312153643479.png",alt:"image-20240312153643479"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312153659228.png",alt:"image-20240312153659228"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240312153830565.png",alt:"image-20240312153830565"}})]),a._v(" "),t("hr"),a._v(" "),t("p",[t("strong",[a._v("标记清除算法：")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240314142719599.png",alt:"image-20240314142719599"}})]),a._v(" "),t("p",[a._v("内存是连续的，在对象被删除之后，就会出现许多不连续的随机大小的可用内存单元，当我们需要一片连续的内存单元来使用时，可能无法找到满足要求的空闲内存。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240314142748912.png",alt:"image-20240314142748912"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240314142808300.png",alt:"image-20240314142808300"}})]),a._v(" "),t("p",[a._v("也可能没有合适的内存空间，从而再次触发垃圾回收以获得更多的可用内存。")]),a._v(" "),t("hr"),a._v(" "),t("p",[t("strong",[a._v("复制算法：")])]),a._v(" "),t("p",[a._v("核心思想就是：使用两块内存，GC的时候将存活对象复制到另一片空间，那么原来的那块内存空间就可以全部回收掉，就不存在内存碎片的问题。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240314144220073.png",alt:"image-20240314144220073"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240314144237906.png",alt:"image-20240314144237906"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240314144432619.png",alt:"image-20240314144432619"}})]),a._v(" "),t("hr"),a._v(" "),t("p",[t("strong",[a._v("标记整理算法：")])]),a._v(" "),t("p",[a._v("标记整理算法的出现就是解决标记清除算法的内存碎片问题，多了一个整理的过程："),t("strong",[a._v("把存活的对象移动到内存的一段，那么剩下的就是可以回收的连续内存空间。回收即可")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240314144655654.png",alt:"image-20240314144655654"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240314144720617.png",alt:"image-20240314144720617"}})]),a._v(" "),t("hr"),a._v(" "),t("p",[t("strong",[a._v("分代GC:")])]),a._v(" "),t("p",[t("strong",[a._v("分代GC是对上述算法的组合使用")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240314145331292.png",alt:"image-20240314145331292"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240316223139641.png",alt:"image-20240316223139641"}})]),a._v(" "),t("p",[t("strong",[a._v("在YoungGC的过程中，存活下来的对象的年龄会加一，当达到某个阈值的时候，我们就认为，该对象是存活时间较长的对象，会长期被使用，于是会移动到老年区。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240316223226521.png",alt:"image-20240316223226521"}})]),a._v(" "),t("p",[a._v("​")]),a._v(" "),t("p",[t("strong",[a._v("在YoungGC的过程中，存活下来的对象的年龄会加一，当达到某个阈值的时候，我们就认为，该对象是存活时间较长的对象，会长期被使用，于是会移动到老年区。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240316223506119.png",alt:"image-20240316223506119"}})]),a._v(" "),t("p",[a._v("放入老年代的对象也不一定年龄全部都达到了阈值，也可能因为年轻代整个已经满了放不下对象了，会将一些未达到阈值的对象放入老年代。")]),a._v(" "),t("p",[t("strong",[a._v("当老年区满了首先会进行一次YoungGC ，如果年轻代GC后可以放心将要放入老年区的对象，那就没事，否则会触发FullGC，也就是对整个方法区和堆区的回收。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240316225003268.png",alt:"image-20240316225003268"}})]),a._v(" "),t("p",[t("strong",[a._v("最主要的原因就是减少FullGC，因为FullGC对应的STW时间是比较长的，时间过长就会影响业务程序的运行。也就是尽可能在YoungGC的时候将对象回收掉。减少FullGC的频次")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240316225333037.png",alt:"image-20240316225333037"}})]),a._v(" "),t("blockquote",[t("p",[a._v("Young GC 与 Full GC")])]),a._v(" "),t("h4",{attrs:{id:"垃圾回收的具体实现-垃圾回收器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收的具体实现-垃圾回收器"}},[a._v("#")]),a._v(" 垃圾回收的具体实现-垃圾回收器")]),a._v(" "),t("br"),a._v(" "),t("h2",{attrs:{id:"jvm调优"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优"}},[a._v("#")]),a._v(" JVM调优")])])}),[],!1,null,null,null);t.default=s.exports}}]);