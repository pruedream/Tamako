(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{371:function(a,t,s){"use strict";s.r(t);var r=s(4),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"算法刷题思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法刷题思想"}},[a._v("#")]),a._v(" 算法刷题思想")]),a._v(" "),t("h2",{attrs:{id:"去重"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#去重"}},[a._v("#")]),a._v(" 去重")]),a._v(" "),t("h3",{attrs:{id:"哈希保存元素状态法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哈希保存元素状态法"}},[a._v("#")]),a._v(" 哈希保存元素状态法")]),a._v(" "),t("p",[a._v("通过哈希表存储已经出现过的元素")]),a._v(" "),t("h3",{attrs:{id:"双指针"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双指针"}},[a._v("#")]),a._v(" 双指针")]),a._v(" "),t("p",[a._v("先排序，再基于排序的基础上按照具体情况进行去重 如三数之和，以及回溯中需要去重的题")]),a._v(" "),t("h2",{attrs:{id:"递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[a._v("#")]),a._v(" 递归")]),a._v(" "),t("p",[t("strong",[a._v("对于递归算法，最重要的就是明确递归函数的定义")]),a._v("，不要跳进递归（你的脑袋能压几个栈呀？），而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果：主要是根据具体的处理代码来判断。也就是说，"),t("strong",[a._v("单个节点的处理代码就是该递归函数的意义")])]),a._v(" "),t("p",[a._v("往下的过程就是递，再从下返回上的过程就是归")]),a._v(" "),t("p",[a._v("在向下的过程中把问题解决，还是在回退的过程中把问题解决，注意与回溯的联系，进行对比")]),a._v(" "),t("p",[a._v("快速排序                            反转链表                                   全排列")]),a._v(" "),t("p",[a._v("基本就是处理逻辑是在递归代码前还是后")]),a._v(" "),t("h3",{attrs:{id:"无返回值的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无返回值的"}},[a._v("#")]),a._v(" 无返回值的")]),a._v(" "),t("p",[a._v("在递的过程中解决问题")]),a._v(" "),t("p",[a._v("处理逻辑是在递归代码之前的，也就是说，他不需要自己下层的递归函数有任何返回值来帮助进行程序的运行，")]),a._v(" "),t("p",[a._v("解决问题是从上往下解决问题。")]),a._v(" "),t("h3",{attrs:{id:"有返回值的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有返回值的"}},[a._v("#")]),a._v(" 有返回值的")]),a._v(" "),t("p",[a._v("在归的过程中解决问题")]),a._v(" "),t("p",[a._v("处理逻辑是在递归代码之后的，也就是说，他需要自己下层的递归函数有任何返回值来帮助进行程序的运行，")]),a._v(" "),t("p",[a._v("解决问题是从下往上执行问题，因为上面的递归函数需要下面的递归函数的返回值来帮助程序运行。")]),a._v(" "),t("h3",{attrs:{id:"注意"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[a._v("#")]),a._v(" 注意")]),a._v(" "),t("p",[a._v("上面举例的无返回值与有返回值，实际上并不准确，因为无返回值也可以在归中解决问题，有返回值也能再递中解决问题，"),t("strong",[a._v("总结就是递归有两种解决方法：从上往下，递中解决，处理逻辑是在递归代码之前。从下往上，归中解决，处理逻辑是在递归代码之后的。")]),a._v(" 补充： 处理逻辑是在递归代码之前与处理逻辑是在递归代码之后，并不是该两中方法各自的特点，而是都能存在于对方的方法中，如二叉树的遍历"),t("strong",[a._v("实际上关键在于，你想在递归前做些事情就写在递归代码前，想在递归后做些事情就写在递归代码后。")])]),a._v(" "),t("h2",{attrs:{id:"回溯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回溯"}},[a._v("#")]),a._v(" 回溯")]),a._v(" "),t("h3",{attrs:{id:"去重问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#去重问题"}},[a._v("#")]),a._v(" 去重问题")]),a._v(" "),t("p",[a._v("先排序")]),a._v(" "),t("p",[a._v("去重是判断是否在同一层使用过，对应到代码是本次for循环当中的元素。下一层不管：所谓下一层，就是递归向下的下一层。for循环横向遍历（同一层），递归纵向向下到下一层。")]),a._v(" "),t("p",[a._v("for循环内的代码都是本层的逻辑")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240208214549997.png",alt:"image-20240208214549997"}})]),a._v(" "),t("p",[a._v("组合与排列的去重逻辑都一样")]),a._v(" "),t("p",[a._v("一定要先排序")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("if(i!=0 && nums[i] == nums[i-1] && !used[i-1]){\n    continue;\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("h2",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[a._v("#")]),a._v(" 链表")]),a._v(" "),t("h3",{attrs:{id:"反转"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反转"}},[a._v("#")]),a._v(" 反转")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/",target:"_blank",rel:"noopener noreferrer"}},[a._v("递归魔法：反转单链表 | labuladong 的算法笔记 (gitee.io)"),t("OutboundLink")],1)]),a._v(" "),t("p",[a._v("反转整个引申到反转前n个再引申到反转链表的指定局部，       递归法")]),a._v(" "),t("h3",{attrs:{id:"环形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#环形"}},[a._v("#")]),a._v(" 环形")]),a._v(" "),t("p",[a._v("哈希法")]),a._v(" "),t("p",[a._v("快慢指针， fast为slow的两倍速，相遇就是有环，若需进一步得出环的起始节点。快慢指针，相遇后，启一个新的head节点与slow同时遍历，直到相等，就是起始点")]),a._v(" "),t("h3",{attrs:{id:"删除链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除链表"}},[a._v("#")]),a._v(" 删除链表")]),a._v(" "),t("p",[a._v("删除 也需要用到双指针")]),a._v(" "),t("h2",{attrs:{id:"动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[a._v("#")]),a._v(" 动态规划")]),a._v(" "),t("h2",{attrs:{id:"二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[a._v("#")]),a._v(" 二叉树")]),a._v(" "),t("p",[a._v("二叉树的处理离不开二叉树的遍历，一般而言用的是三种：前序（中左右），中序（左中右），后序（左右中）")]),a._v(" "),t("p",[t("strong",[a._v("不管是什么遍历，处理逻辑一定是在中处理的")]),a._v("  所以前序相当是从上往下处理，后序是从下往上")]),a._v(" "),t("p",[a._v("没每种遍历都有自己的特性，要根据具体情况使用合适的遍历")])])}),[],!1,null,null,null);t.default=v.exports}}]);