(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{388:function(t,a,s){"use strict";s.r(a);var r=s(4),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"多级缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多级缓存"}},[t._v("#")]),t._v(" 多级缓存")]),t._v(" "),a("p",[t._v("在只使用Redis作为缓存的情况下，存在缓存穿透，缓存击穿，缓存雪崩等生产问题，虽然都有对应的解决方法，但不是最优的方法**，并且传统缓存策略一般是请求到tomcat后，先查询redis，如果未命中则查询数据库请求要先经过tomcat处理，tomcat的性能成为整个系统的瓶颈**。在系统的架构比较大，系统比较复杂时候，可以采用多级缓存来实现缓存。")]),t._v(" "),a("h2",{attrs:{id:"多级缓存的架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多级缓存的架构"}},[t._v("#")]),t._v(" 多级缓存的架构")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/2910022-20230901173145304-131250914.png",alt:"img"}})]),t._v(" "),a("p",[t._v("用户浏览器缓存为第一层缓存，nginx用来实现静态资源的缓存以及相关数据的缓存为第二层缓存，Redis作为第三层缓存，tomcat JVM进程缓存作为第四层缓存，最后才是mysql， 在集群情况下对于不共享缓存，我们在路由的时候需要修改路由规则，使得同一类请求都会访问到同一个节点，可以采用hash路由的方式保证。")]),t._v(" "),a("p",[t._v("接下来就是缓存的同步问题，就放在下期吧。今天累了。")])])}),[],!1,null,null,null);a.default=e.exports}}]);