(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{421:function(a,t,l){"use strict";l.r(t);var n=l(4),r=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"什么是canal"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是canal"}},[a._v("#")]),a._v(" 什么是canal")]),a._v(" "),t("p",[a._v("官话就不说了，直接一句话 canal是一个用来"),t("strong",[a._v("同步增量数据的一个工具")]),a._v("。")]),a._v(" "),t("p",[a._v("canal的工作原理就是把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地，比如MySQL，Kafka，Elastic Search等等。")]),a._v(" "),t("h2",{attrs:{id:"canal的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#canal的原理"}},[a._v("#")]),a._v(" canal的原理")]),a._v(" "),t("p",[a._v("canal的实现是基于mysql的主从复制，")]),a._v(" "),t("p",[a._v("Master mysql会将数据变更的操作记录到二进制文件中 binlog ,此时Slave mysql 会有一个线程不断地去读取该文件中的增量内容，然后写入到自己的中继日志 reloylog中，另一个线程负责执行reloylog中的记录，对从数据库的数据进行跟新，canal就是这么个原理，他同样会去读取该二进制文件，并通知下游的服务进行相关信息的跟新。")]),a._v(" "),t("h2",{attrs:{id:"canal的使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#canal的使用场景"}},[a._v("#")]),a._v(" canal的使用场景")]),a._v(" "),t("p",[a._v("canal的主要使用场景是用于缓存的跟新，保证数据库和缓存的一致性，相比于原来的更新数据库和更新缓存耦合的操作，使用canal来进行缓存的跟新，解除了更新数据库和更新缓存耦合，减少了代码的复杂程度，只需分别关注更新数据库和更新缓存的操作即可")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/2910022-20230901172921745-339032687.png",alt:"img"}})])])}),[],!1,null,null,null);t.default=r.exports}}]);