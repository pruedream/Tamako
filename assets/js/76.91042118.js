(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{339:function(t,a,s){"use strict";s.r(a);var r=s(4),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"正向代理和反向代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正向代理和反向代理"}},[t._v("#")]),t._v(" 正向代理和反向代理")]),t._v(" "),a("h2",{attrs:{id:"什么是代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是代理"}},[t._v("#")]),t._v(" 什么是代理")]),t._v(" "),a("p",[t._v("代理的本质就是对请求进行转发，根据侧重点的不同而分为正向代理和反向代理。正向代理侧重于客户端，目的主要是帮助客户端访问访问不到的资源，同时隐藏客户端的访问。而反向代理侧重于服务端，目的主要是对服务端进行隐藏，客户端不知道实际相应的服务器。")]),t._v(" "),a("h2",{attrs:{id:"正向代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正向代理"}},[t._v("#")]),t._v(" 正向代理")]),t._v(" "),a("p",[t._v("如我们现在想要访问谷歌,但是由于某些原因,无法直接访问到谷歌,我们可以通过连接一台代理服务器,代理服务将我们的请求提交到谷歌,然后再将谷歌的响应反馈给我们,对于谷歌而言,它只知道有一个请求过来,但是它并不会知道我们是无法直接访问它的。")]),t._v(" "),a("h2",{attrs:{id:"反向代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#反向代理"}},[t._v("#")]),t._v(" 反向代理")]),t._v(" "),a("p",[t._v("比如我们访问百度网站，具体内部的服务器节点我们不知道。现实中我们通过访问百度的代理服务器后，代理服务器给我们转发请求到他们N多的服务器节点中的一个给我们进行搜索后将结果返回,此时,代理服务器对我们客户端来说就充当了提供响应的服务器,但是对于目标服务器来说,它只是进行了一个请求和转发的功能。")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("可能有人会觉得正向反向不都一样的访问吗，有什么区别，其实本质上二者并没有什么区别，都是对请求进行转发和响应。区分二者的关键在于你代理的目的是啥，目的决定了其性质。")]),t._v(" "),a("p",[t._v("比如A服务器现在无法访问C服务器的资源，我们就可以考虑找个可以访问C服务器的B服务器来帮A访问，然后把结果响应给A。从使用目的上来看，B代理服务器的根本目的就是为了服务A。")]),t._v(" "),a("p",[t._v("现在换个场景，服务B现在要对外提供服务，但是网上的东西，水太深，B把握不住，搞不好会被恶意攻击。所以可以考虑找来C服务来挡在前面帮自己挡在请求前，帮自己直面外部错综复杂的网络（外网），自己则安全的待在自己的一亩三分地（内网）处理经过C服务器经过处理的无恶意的请求。从使用目的上看，C服务器的目的就是为了服务B。")]),t._v(" "),a("p",[t._v("正向代理代理的是客户端，服务端不知道实际发起请求访问的客户端，反向代理代理的是服务端，客户端不知道实际响应请求的服务器")])])}),[],!1,null,null,null);a.default=v.exports}}]);