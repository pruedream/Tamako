(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{402:function(t,r,_){"use strict";_.r(r);var e=_(4),v=Object(e.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"堆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆")]),t._v(" "),r("p",[t._v("完全二叉树的定义仅为个人理解：除了最底层可以是不满的，其他层必须都是满的，底层节点不满的时候，底层节点必须是连在一起的")]),t._v(" "),r("p",[t._v("打个比方：图二 就是底层节点不满的情况，节点4,5与节点6之间就断开了。其要变成完全二叉树要么把6删除，要么在4,5,与6之间加一个加点，也就是3节点的左子树。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240220205919157.png",alt:"image-20240220205919157"}})]),t._v(" "),r("p",[t._v("heap 其实是一个"),r("strong",[t._v("抽象的数据结构")]),t._v("，或者说是"),r("strong",[t._v("逻辑上的数据结构")]),t._v("，并不是一个物理上真实存在的数据结构。简单点说就是，堆并没有其对应的实际的物理数据结构，像数组，链表，二叉树等都有自己对应的物理层面的数据结构，而堆只是一个逻辑上的数据结构，该数据结构有着特定功能。")]),t._v(" "),r("p",[t._v("堆的实现有多种，主要的目的就是要实现堆这种数据结构的功能，也就是实现"),r("strong",[t._v("优先级队列")]),t._v("，**要能够动态的将放入堆的数据按照优先级进行排序，注意是动态的，**不是说像存在一个普通数组一样，每加一个数据就重新排一次序，这样效率太低，优先级队列是能够在添加，删除的过程中动态的维护优先级。")]),t._v(" "),r("p",[t._v("此处介绍二叉堆")]),t._v(" "),r("p",[r("strong",[t._v("二叉堆")])]),t._v(" "),r("p",[t._v("标准定义上，我们认为一颗树满足以下的两点，就是一个堆，")]),t._v(" "),r("ol",[r("li",[t._v("一颗完全二叉树")]),t._v(" "),r("li",[t._v("每个节点的值大于等于（或小于等于）其子树中每个节点的值")])]),t._v(" "),r("p",[t._v("根据子节点与父节点值的大小关系，可以把堆分为，")]),t._v(" "),r("ol",[r("li",[r("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%9C%80%E5%A4%A7%E5%A0%86%2F4633143",target:"_blank",rel:"noopener noreferrer"}},[t._v("最大堆"),r("OutboundLink")],1),t._v("（也叫大根堆，大顶堆），任意父节点都比其子节点的值要大")]),t._v(" "),r("li",[r("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%9C%80%E5%B0%8F%E5%A0%86",target:"_blank",rel:"noopener noreferrer"}},[t._v("最小堆"),r("OutboundLink")],1),t._v("（也叫小根堆，小顶堆），任意父节点都比其子节点的值要小")])]),t._v(" "),r("p",[t._v("在二叉堆的实现上实际上是使用数组来实现的")]),t._v(" "),r("p",[t._v("树的存储方式一般有"),r("strong",[t._v("链式存储")]),t._v("和"),r("strong",[t._v("线性存储")]),t._v("，分别对应我们常见的"),r("strong",[t._v("链表")]),t._v("和"),r("strong",[t._v("数组")]),t._v("两种方式，对于完全二叉树而言，用"),r("strong",[t._v("数组来存储是非常节省存储空间的")]),t._v("，因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点，")]),t._v(" "),r("p",[t._v("实现可参考")]),t._v(" "),r("p",[t._v("https://labuladong.gitee.io/algo/data-structure/binary-heap-priority-queue/#%E4%BA%8C%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E6%A6%82%E8%A7%88")])])}),[],!1,null,null,null);r.default=v.exports}}]);