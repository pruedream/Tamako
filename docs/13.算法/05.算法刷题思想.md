---
title: 算法刷题思想
date: 2024-02-04 21:29:18
permalink: /pages/0fcb1b/
categories:
  - 算法
tags:
  - 
author: 
  name: pruedream
  link: https://github.com/pruedream
---
# 算法刷题思想



## 去重



### 哈希保存元素状态法

通过哈希表存储已经出现过的元素



### 双指针

先排序，再基于排序的基础上按照具体情况进行去重 如三数之和，以及回溯中需要去重的题



## 递归

**对于递归算法，最重要的就是明确递归函数的定义**，不要跳进递归（你的脑袋能压几个栈呀？），而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果：主要是根据具体的处理代码来判断。也就是说，**单个节点的处理代码就是该递归函数的意义**



往下的过程就是递，再从下返回上的过程就是归

在向下的过程中把问题解决，还是在回退的过程中把问题解决，注意与回溯的联系，进行对比

快速排序                            反转链表                                   全排列

基本就是处理逻辑是在递归代码前还是后	

### 无返回值的

在递的过程中解决问题

处理逻辑是在递归代码之前的，也就是说，他不需要自己下层的递归函数有任何返回值来帮助进行程序的运行，

解决问题是从上往下解决问题。

### 有返回值的

在归的过程中解决问题

处理逻辑是在递归代码之后的，也就是说，他需要自己下层的递归函数有任何返回值来帮助进行程序的运行，

解决问题是从下往上执行问题，因为上面的递归函数需要下面的递归函数的返回值来帮助程序运行。



### 注意

上面举例的无返回值与有返回值，实际上并不准确，因为无返回值也可以在归中解决问题，有返回值也能再递中解决问题，**总结就是递归有两种解决方法：从上往下，递中解决，处理逻辑是在递归代码之前。从下往上，归中解决，处理逻辑是在递归代码之后的。** 补充： 处理逻辑是在递归代码之前与处理逻辑是在递归代码之后，并不是该两中方法各自的特点，而是都能存在于对方的方法中，如二叉树的遍历**实际上关键在于，你想在递归前做些事情就写在递归代码前，想在递归后做些事情就写在递归代码后。**





## 回溯



### 去重问题

先排序

去重是判断是否在同一层使用过，对应到代码是本次for循环当中的元素。下一层不管：所谓下一层，就是递归向下的下一层。for循环横向遍历（同一层），递归纵向向下到下一层。

for循环内的代码都是本层的逻辑



![image-20240208214549997](https://raw.githubusercontent.com/pruedream/PictureBed/main/image/image-20240208214549997.png)



组合与排列的去重逻辑都一样

一定要先排序

```
if(i!=0 && nums[i] == nums[i-1] && !used[i-1]){
    continue;
}
```



## 链表



### 反转

[递归魔法：反转单链表 | labuladong 的算法笔记 (gitee.io)](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/)

反转整个引申到反转前n个再引申到反转链表的指定局部，       递归法

## 动态规划







## 二叉树



二叉树的处理离不开二叉树的遍历，一般而言用的是三种：前序（中左右），中序（左中右），后序（左右中）

**不管是什么遍历，处理逻辑一定是在中处理的**  所以前序相当是从上往下处理，后序是从下往上



没每种遍历都有自己的特性，要根据具体情况使用合适的遍历

